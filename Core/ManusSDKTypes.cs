// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by ManusCodeGenerator.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

namespace Manus
{
    public partial class CoreSDK
    {
        /// <summary>The return values that can be given by SDK wrapper functions.</summary>
        public enum SDKReturnCode
        {
            /// <summary>No issues occurred.</summary>
            Success = 0,
            /// <summary>Something went wrong, but no specific reason can be given.</summary>
            Error = 1,
            /// <summary>One of the arguments given had an invalid value.</summary>
            InvalidArgument = 2,
            /// <summary>
            /// <para>The size of an argument given (e.g. an array) does not match the size</para>
            /// <para>of the data that it is intended to hold.</para>
            /// </summary>
            ArgumentSizeMismatch = 3,
            /// <summary>A string of an unsupported size was encountered.</summary>
            UnsupportedStringSizeEncountered = 4,
            /// <summary>The Core SDK is not available.</summary>
            SdkNotAvailable = 5,
            /// <summary>The network host finder is not available.</summary>
            HostFinderNotAvailable = 6,
            /// <summary>The data requested is not available.</summary>
            DataNotAvailable = 7,
            /// <summary>Failed to allocate memory for something.</summary>
            MemoryError = 8,
            /// <summary>Something went wrong in the SDK internally.</summary>
            InternalError = 9,
            /// <summary>The function was not intended to be called at this time.</summary>
            FunctionCalledAtWrongTime = 10,
            /// <summary>No connection to Core was made.</summary>
            NotConnected = 11,
            /// <summary>The connection with Core timed out.</summary>
            ConnectionTimeout = 12,
            /// <summary>using an uninitialized ID is bad.</summary>
            InvalidID = 13,
            /// <summary>memory unallocated or just a null pointer passed where it wasn't supposed to be!</summary>
            NullPointer = 14,
            /// <summary>null sequence type for polygon calibration</summary>
            InvalidSequence = 15,
            /// <summary>don't forget to set the coordinate system type or there will be trouble</summary>
            NoCoordinateSystemSet = 16,
            /// <summary>if everything is being terminated. don't restart</summary>
            SdkIsTerminating = 17,
            /// <summary>the stub has been reset but someone is tryign to use it anyway. usually after a shutdown of the SDK.</summary>
            StubNullPointer = 18,
            /// <summary>Skeleton could not be loaded. usually when using more then the max skeletons per session (32).</summary>
            SkeletonNotLoaded = 19,
            /// <summary>Function not available for this version of the SDK</summary>
            FunctionNotAvailable = 20,
            /// <summary>Function not available for this version of the SDK</summary>
            MAX_SIZE = 21
        }

        /// <summary>
        /// <para>Used to tell what client is using the wrapper.</para>
        /// <para>This makes the session easier to identify in the landscape.</para>
        /// </summary>
        public enum SessionType
        {
            Unknown = 0,
            UnityPlugin = 1,
            UnrealPlugin = 2,
            CoreSDK = 3,
            Xsens = 4,
            Optitrack = 5,
            MotionBuilder = 6,
            VRED = 7,
            OpenXR = 8,
            Qualisys = 9
        }

        /// <summary>Describes the different types of trackers that can be used.</summary>
        public enum TrackerType
        {
            Unknown = 0,
            Head = 1,
            Waist = 2,
            LeftHand = 3,
            RightHand = 4,
            LeftFoot = 5,
            RightFoot = 6,
            LeftUpperArm = 7,
            RightUpperArm = 8,
            LeftUpperLeg = 9,
            RightUpperLeg = 10,
            Controller = 11,
            Camera = 12,
            MAX_SIZE = 13
        }

        /// <summary>Describes the tracking quality.</summary>
        public enum TrackingQuality
        {
            Untrackable = 0,
            BadTracking = 1,
            Trackable = 2
        }

        /// <summary>Describes the different types of tracker systems.</summary>
        public enum TrackerSystemType
        {
            Unknown = 0,
            Antilatency = 1,
            ART = 2,
            OpenVR = 3,
            Optitrack = 4,
            Vicon = 5,
            OpenXR = 6
        }

        /// <summary>Describes the paired state of the device.</summary>
        public enum DevicePairedState
        {
            Unknown = 0,
            Paired = 1,
            Unpaired = 2,
            Pairing = 3
        }

        /// <summary>Describes the different types of device classes.</summary>
        public enum DeviceClassType
        {
            Unknown = 0,
            Dongle = 1,
            Glove = 2,
            Glongle = 3
        }

        /// <summary>Describes the different types of Manus devices.</summary>
        public enum DeviceFamilyType
        {
            Unknown = 0,
            Prime1 = 1,
            Prime2 = 2,
            PrimeX = 3,
            Quantum = 4,
            Prime3 = 5,
            Virtual = 6
        }

        /// <summary>Describes the different types of profile used during the calibration.</summary>
        public enum ProfileType
        {
            Hands = 0,
            FullBody = 1,
            MAX_SIZE = 2
        }

        /// <summary>The different types of body measurements used for the polygon calibration.</summary>
        public enum MeasurementType
        {
            Unknown = 0,
            PlayerHeight = 1,
            SpineLength = 2,
            NeckLength = 3,
            UpperArmLength = 4,
            LowerArmLength = 5,
            ArmLength = 6,
            ArmSpan = 7,
            UpperLegLength = 8,
            LowerLegLength = 9,
            LegLength = 10,
            HandLength = 11,
            FootLength = 12,
            HipWidth = 13,
            ShoulderWidth = 14,
            ShoulderHeight = 15,
            HeadLength = 16,
            Thickness = 17,
            ArmRatio = 18,
            LegRatio = 19,
            MAX_SIZE = 20
        }

        /// <summary>Describes the different types of tracker offsets.</summary>
        public enum TrackerOffsetType
        {
            Unknown = 0,
            HeadTrackerToHead = 1,
            HeadTrackerToTopOfHead = 2,
            LeftHandTrackerToWrist = 3,
            RightHandTrackerToWrist = 4,
            LeftFootTrackerToAnkle = 5,
            RightFootTrackerToAnkle = 6,
            HipTrackerToHip = 7,
            HipTrackerToLeftLeg = 8,
            HipTrackerToRightLeg = 9,
            LeftUpperArmTrackerToElbow = 10,
            RightUpperArmTrackerToElbow = 11,
            LeftUpperArmTrackerToShoulder = 12,
            RightUpperArmTrackerToShoulder = 13,
            MAX_SIZE = 14
        }

        /// <summary>Describes the different types of extra tracker offsets.</summary>
        public enum ExtraTrackerOffsetType
        {
            Unknown = 0,
            HeadForward = 1,
            HipForward = 2,
            HipHeight = 3,
            MAX_SIZE = 4
        }

        /// <summary>Describes the different types of body measurement units.</summary>
        public enum MeasurementUnit
        {
            Meters = 0,
            Percentage = 1
        }

        /// <summary>Describes the different types of body measurement categories used for the polygon calibration.</summary>
        public enum MeasurementCategory
        {
            Misc = 0,
            Generic = 1,
            Arms = 2,
            Legs = 3,
            Body = 4
        }

        /// <summary>Describes the different possibilities for the update status.</summary>
        public enum UpdateStatusEnum
        {
            Unknown = 0,
            NoUpdateAvailable = 1,
            UpdateAvailable = 2,
            MandatoryUpdateAvailable = 3,
            Updating = 4
        }

        /// <summary>Describes the different skeleton types.</summary>
        public enum SkeletonType
        {
            Invalid = 0,
            Hand = 1,
            Body = 2,
            Both = 3
        }

        /// <summary>Describes the possible data that can be used for the skeleton animation.</summary>
        public enum SkeletonTargetType
        {
            Invalid = 0,
            UserData = 1,
            UserIndexData = 2,
            AnimationData = 3,
            GloveData = 4
        }

        /// <summary>Describes the possible nodes types used when setting up the skeleton.</summary>
        public enum NodeType
        {
            Invalid = 0,
            Joint = 1,
            Mesh = 2,
            Leaf = 3,
            Collider = 4
        }

        /// <summary>Describes the settings that can be applied to a node, it is defined as a flag so that more than one setting can be set.</summary>
        [Flags]
        public enum NodeSettingsFlag
        {
            None = 0,
            IK = 1,
            Foot = 2,
            RotationOffset = 4,
            Leaf = 8
        }

        /// <summary>Describes the possible chain types used when setting up the skeleton.</summary>
        public enum ChainType
        {
            Invalid = 0,
            Arm = 1,
            Leg = 2,
            Neck = 3,
            Spine = 4,
            FingerThumb = 5,
            FingerIndex = 6,
            FingerMiddle = 7,
            FingerRing = 8,
            FingerPinky = 9,
            Pelvis = 10,
            Head = 11,
            Shoulder = 12,
            Hand = 13,
            Foot = 14,
            Toe = 15
        }

        /// <summary>Describes the possible collider types.</summary>
        public enum CollisionType
        {
            None = 0,
            Discrete = 1,
            Continuous = 2
        }

        /// <summary>Describes the possible collider types.</summary>
        public enum ColliderType
        {
            Invalid = 0,
            Sphere = 1,
            Capsule = 2,
            Box = 3
        }

        /// <summary>Describes the possible chain side.</summary>
        public enum Side
        {
            Invalid = 0,
            Left = 1,
            Right = 2,
            Center = 3
        }

        /// <summary>Describes which sensor data the hand motion is based on.</summary>
        public enum HandMotion
        {
            None = 0,
            IMU = 1,
            Tracker = 2,
            TrackerRotationOnly = 3,
            Auto = 4
        }

        /// <summary>Describes the direction of the coordinate system axis in 3d space.</summary>
        public enum AxisDirection
        {
            Invalid = 0,
            Backward = 1,
            Left = 2,
            Down = 3,
            Up = 4,
            Right = 5,
            Forward = 6
        }

        /// <summary>
        /// <para>Describes the view of the coordinate system axis.</para>
        /// <para>Consider yourself sitting in front of your computer screen.</para>
        /// <para>From Viewer means it goes into the screen, so away from you.</para>
        /// <para>To Viewer means the axis goes from the screen towards you.</para>
        /// </summary>
        public enum AxisView
        {
            Invalid = 0,
            ZFromViewer = 1,
            YFromViewer = 2,
            XFromViewer = 3,
            XToViewer = 4,
            YToViewer = 5,
            ZToViewer = 6
        }

        /// <summary>Describes the polarity of the coordinate system axis.</summary>
        public enum AxisPolarity
        {
            Invalid = 0,
            NegativeZ = 1,
            NegativeY = 2,
            NegativeX = 3,
            PositiveX = 4,
            PositiveY = 5,
            PositiveZ = 6
        }

        /// <summary>Describes the possible types for system messages received from core.</summary>
        public enum SystemMessageType
        {
            Unknown = 0,
            LibDebugReplugDongle = 1,
            LibDebugRxStall = 2,
            LibDebugTxStall = 3,
            TrackerError = 4,
            TrackerOk = 5,
            TrackerSystemOutOfDate = 6,
            GloveSanityErrorPSOCInit = 7,
            GloveSanityErrorQCBatV = 8,
            GloveSanityErrorQCLRACalib = 9,
            GloveSanityErrorQCFlexInit = 10,
            GloveSanityErrorQCIMUInit = 11,
            GloveSanityErrorQCIMUCalib = 12,
            GloveSanityErrorQCID = 13,
            GloveSanityErrorQCInterCPU = 14,
            SessionConnectionVersionMismatch = 15,
            TemporarySkeletonModified = 16,
            SessionRefusedDueToLicenseIssue = 17,
            LaunchDevTools = 18
        }

        /// <summary>Describes the possible types for the ergonomics data.</summary>
        public enum ErgonomicsDataType
        {
            LeftFingerThumbMCPSpread = 0,
            LeftFingerThumbMCPStretch = 1,
            LeftFingerThumbPIPStretch = 2,
            LeftFingerThumbDIPStretch = 3,
            LeftFingerIndexMCPSpread = 4,
            LeftFingerIndexMCPStretch = 5,
            LeftFingerIndexPIPStretch = 6,
            LeftFingerIndexDIPStretch = 7,
            LeftFingerMiddleMCPSpread = 8,
            LeftFingerMiddleMCPStretch = 9,
            LeftFingerMiddlePIPStretch = 10,
            LeftFingerMiddleDIPStretch = 11,
            LeftFingerRingMCPSpread = 12,
            LeftFingerRingMCPStretch = 13,
            LeftFingerRingPIPStretch = 14,
            LeftFingerRingDIPStretch = 15,
            LeftFingerPinkyMCPSpread = 16,
            LeftFingerPinkyMCPStretch = 17,
            LeftFingerPinkyPIPStretch = 18,
            LeftFingerPinkyDIPStretch = 19,
            RightFingerThumbMCPSpread = 20,
            RightFingerThumbMCPStretch = 21,
            RightFingerThumbPIPStretch = 22,
            RightFingerThumbDIPStretch = 23,
            RightFingerIndexMCPSpread = 24,
            RightFingerIndexMCPStretch = 25,
            RightFingerIndexPIPStretch = 26,
            RightFingerIndexDIPStretch = 27,
            RightFingerMiddleMCPSpread = 28,
            RightFingerMiddleMCPStretch = 29,
            RightFingerMiddlePIPStretch = 30,
            RightFingerMiddleDIPStretch = 31,
            RightFingerRingMCPSpread = 32,
            RightFingerRingMCPStretch = 33,
            RightFingerRingPIPStretch = 34,
            RightFingerRingDIPStretch = 35,
            RightFingerPinkyMCPSpread = 36,
            RightFingerPinkyMCPStretch = 37,
            RightFingerPinkyPIPStretch = 38,
            RightFingerPinkyDIPStretch = 39,
            MAX_SIZE = 40
        }

        /// <summary>Describes the possible Manus license types.</summary>
        public enum LicenseType
        {
            Undefined = 0,
            Polygon = 1,
            CoreXO = 2,
            CorePro = 3,
            CoreXOPro = 4,
            CoreX = 5,
            CoreO = 6,
            CoreQ = 7,
            CoreXPro = 8,
            CoreOPro = 9,
            CoreQPro = 10,
            CoreXOQPro = 11,
            CoreXR = 12,
            CorePrimeThree = 13
        }

        /// <summary>The possible FPS rates</summary>
        public enum TimecodeFPS
        {
            TimecodeFPS_Undefined = 0,
            TimecodeFPS_23_976 = 1,
            TimecodeFPS_24 = 2,
            TimecodeFPS_25 = 3,
            TimecodeFPS_29_97 = 4,
            TimecodeFPS_30 = 5,
            TimecodeFPS_48 = 6,
            TimecodeFPS_50 = 7,
            TimecodeFPS_59_94 = 8,
            TimecodeFPS_60 = 9,
            TimecodeFPS_29_97DF = 10,
            TimecodeFPS_59_94DF = 11
        }

        public enum FingerJointType
        {
            Invalid = 0,
            Metacarpal = 1,
            Proximal = 2,
            Intermediate = 3,
            Distal = 4,
            Tip = 5
        }

        /// <summary>A 3D vector, used for translations.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusVec3
        {
            public float x;
            public float y;
            public float z;

            public ManusVec3(float p_X,float p_Y,float p_Z)
            {
                x = p_X;
                y = p_Y;
                z = p_Z;
            }
        }

        /// <summary>A 2D vector, used for translations.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusVec2
        {
            public float x;
            public float y;

            public ManusVec2(float p_X,float p_Y)
            {
                x = p_X;
                y = p_Y;
            }
        }

        /// <summary>A quaternion, used for rotations.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusQuaternion
        {
            public float w;
            public float x;
            public float y;
            public float z;

            public ManusQuaternion(float p_W,float p_X,float p_Y,float p_Z)
            {
                w = p_W;
                x = p_X;
                y = p_Y;
                z = p_Z;
            }
        }

        /// <summary>Transform containing position, rotation and scaling.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusTransform
        {
            public ManusVec3 position;
            public ManusQuaternion rotation;
            public ManusVec3 scale;

            public ManusTransform(ManusVec3 p_Position,ManusQuaternion p_Rotation,ManusVec3 p_Scale)
            {
                position = p_Position;
                rotation = p_Rotation;
                scale = p_Scale;
            }
        }

        /// <summary>Color containing red, green, blue and alpha.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Color
        {
            public float r;
            public float g;
            public float b;
            public float a;

            public Color(float p_R,float p_G,float p_B,float p_A)
            {
                r = p_R;
                g = p_G;
                b = p_B;
                a = p_A;
            }
        }

        /// <summary>A Timestamp</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusTimestampInfo
        {
            public ushort fraction;
            public byte second;
            public byte minute;
            public byte hour;
            public byte day;
            public byte month;
            public uint year;
            [MarshalAs( UnmanagedType.I1 )]
            public bool timecode;

            public ManusTimestampInfo(ushort p_Fraction,byte p_Second,byte p_Minute,byte p_Hour,byte p_Day,byte p_Month,uint p_Year,bool p_Timecode)
            {
                fraction = p_Fraction;
                second = p_Second;
                minute = p_Minute;
                hour = p_Hour;
                day = p_Day;
                month = p_Month;
                year = p_Year;
                timecode = p_Timecode;
            }
        }

        /// <summary>A compressed timestamp</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusTimestamp
        {
            public ulong time;

            public ManusTimestamp(ulong p_Time)
            {
                time = p_Time;
            }
        }

        /// <summary>Information regarding IMU sensors used for calibration</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct IMUCalibrationInfo
        {
            public uint mag;
            public uint acc;
            public uint gyr;
            public uint sys;

            public IMUCalibrationInfo(uint p_Mag,uint p_Acc,uint p_Gyr,uint p_Sys)
            {
                mag = p_Mag;
                acc = p_Acc;
                gyr = p_Gyr;
                sys = p_Sys;
            }
        }

        /// <summary>Used to describe hardware, firmware or ManusCore version.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Version
        {
            public uint major;
            public uint minor;
            public uint patch;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 16 )]
            public string label;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 16 )]
            public string sha;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 16 )]
            public string tag;

            public Version(uint p_Major,uint p_Minor,uint p_Patch,string p_Label,string p_Sha,string p_Tag)
            {
                major = p_Major;
                minor = p_Minor;
                patch = p_Patch;
                label = p_Label;
                sha = p_Sha;
                tag = p_Tag;
            }
        }

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct FirmwareVersion
        {
            public int version;
            public ManusTimestamp timestamp;

            public FirmwareVersion(int p_Version,ManusTimestamp p_Timestamp)
            {
                version = p_Version;
                timestamp = p_Timestamp;
            }
        }

        /// <summary>Stores a single version string.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusVersion
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 16 )]
            public string versionInfo;

            public ManusVersion(string p_VersionInfo)
            {
                versionInfo = p_VersionInfo;
            }
        }

        /// <summary>
        /// <para>Contains information for connecting to a host running Manus Core.</para>
        /// <para>Note that if one of these values is blank, the other will be used when</para>
        /// <para>connecting.</para>
        /// </summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ManusHost
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string hostName;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 40 )]
            public string ipAddress;
            public Version manusCoreVersion;

            public ManusHost(string p_HostName,string p_IpAddress,Version p_ManusCoreVersion)
            {
                hostName = p_HostName;
                ipAddress = p_IpAddress;
                manusCoreVersion = p_ManusCoreVersion;
            }
        }

        /// <summary>Stores the name of a tracker.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerId
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 32 )]
            public string id;

            public TrackerId(string p_Id)
            {
                id = p_Id;
            }
        }

        /// <summary>Stores all the tracker data that can be sent or received.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerData
        {
            public ManusTimestamp lastUpdateTime;
            public TrackerId trackerId;
            public uint userId;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isHmd;
            public TrackerType trackerType;
            public ManusQuaternion rotation;
            public ManusVec3 position;
            public TrackingQuality quality;

            public TrackerData(ManusTimestamp p_LastUpdateTime,TrackerId p_TrackerId,uint p_UserId,bool p_IsHmd,TrackerType p_TrackerType,ManusQuaternion p_Rotation,ManusVec3 p_Position,TrackingQuality p_Quality)
            {
                lastUpdateTime = p_LastUpdateTime;
                trackerId = p_TrackerId;
                userId = p_UserId;
                isHmd = p_IsHmd;
                trackerType = p_TrackerType;
                rotation = p_Rotation;
                position = p_Position;
                quality = p_Quality;
            }
        }

        /// <summary>Stores the information sent by the tracker stream.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerStreamInfo
        {
            public ManusTimestamp publishTime;
            public uint trackerCount;

            public TrackerStreamInfo(ManusTimestamp p_PublishTime,uint p_TrackerCount)
            {
                publishTime = p_PublishTime;
                trackerCount = p_TrackerCount;
            }
        }

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct GestureProbability
        {
            public uint id;
            public float percent;

            public GestureProbability(uint p_Id,float p_Percent)
            {
                id = p_Id;
                percent = p_Percent;
            }
        }

        public const int GESTUREPROBABILITIES_GESTUREDATA_ARRAY_SIZE = 64;

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct GestureProbabilities
        {
            public uint id;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isUserID;
            public uint totalGestureCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 64 )]
            public GestureProbability[] gestureData;
            public uint gestureCount;

            public GestureProbabilities(uint p_Id,bool p_IsUserID,uint p_TotalGestureCount,GestureProbability[] p_GestureData,uint p_GestureCount)
            {
                id = p_Id;
                isUserID = p_IsUserID;
                totalGestureCount = p_TotalGestureCount;
                gestureData = p_GestureData;
                gestureCount = p_GestureCount;
            }
        }

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct GestureStreamInfo
        {
            public ManusTimestamp publishTime;
            public uint gestureProbabilitiesCount;

            public GestureStreamInfo(ManusTimestamp p_PublishTime,uint p_GestureProbabilitiesCount)
            {
                publishTime = p_PublishTime;
                gestureProbabilitiesCount = p_GestureProbabilitiesCount;
            }
        }

        /// <summary>
        /// <para>Stores the information regarding each skeleton node.</para>
        /// <para>The transform is defined as a local or global transform depending on the coordinate system set when initializing the SDK.</para>
        /// <para>See functions CoreSdk_InitializeCoordinateSystemWithVUH and CoreSdk_InitializeCoordinateSystemWithDirection.</para>
        /// </summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonNode
        {
            public uint id;
            public ManusTransform transform;

            public SkeletonNode(uint p_Id,ManusTransform p_Transform)
            {
                id = p_Id;
                transform = p_Transform;
            }
        }

        /// <summary>Stores the information regarding the skeletons that have been added to Manus Core.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonInfo
        {
            public uint id;
            public uint nodesCount;
            public ManusTimestamp publishTime;

            public SkeletonInfo(uint p_Id,uint p_NodesCount,ManusTimestamp p_PublishTime)
            {
                id = p_Id;
                nodesCount = p_NodesCount;
                publishTime = p_PublishTime;
            }
        }

        /// <summary>Stores the information regarding the skeletons coming from the estimation system in core</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct RawSkeletonInfo
        {
            public uint gloveId;
            public uint nodesCount;
            public ManusTimestamp publishTime;

            public RawSkeletonInfo(uint p_GloveId,uint p_NodesCount,ManusTimestamp p_PublishTime)
            {
                gloveId = p_GloveId;
                nodesCount = p_NodesCount;
                publishTime = p_PublishTime;
            }
        }

        /// <summary>Stores the information sent by the skeleton stream.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonStreamInfo
        {
            public ManusTimestamp publishTime;
            public uint skeletonsCount;

            public SkeletonStreamInfo(ManusTimestamp p_PublishTime,uint p_SkeletonsCount)
            {
                publishTime = p_PublishTime;
                skeletonsCount = p_SkeletonsCount;
            }
        }

        public const int ERGONOMICSDATA_DATA_ARRAY_SIZE = 40;

        /// <summary>Stores the received ergonomics data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ErgonomicsData
        {
            public uint id;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isUserID;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 40 )]
            public float[] data;

            public ErgonomicsData(uint p_Id,bool p_IsUserID,float[] p_Data)
            {
                id = p_Id;
                isUserID = p_IsUserID;
                data = p_Data;
            }
        }

        public const int ERGONOMICSSTREAM_DATA_ARRAY_SIZE = 32;

        /// <summary>Stores the information sent by the ergonomics stream.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ErgonomicsStream
        {
            public ManusTimestamp publishTime;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public ErgonomicsData[] data;
            public uint dataCount;

            public ErgonomicsStream(ManusTimestamp p_PublishTime,ErgonomicsData[] p_Data,uint p_DataCount)
            {
                publishTime = p_PublishTime;
                data = p_Data;
                dataCount = p_DataCount;
            }
        }

        /// <summary>Stores all the received dongle data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct DongleLandscapeData
        {
            public uint id;
            public DeviceClassType classType;
            public DeviceFamilyType familyType;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isHaptics;
            public Version hardwareVersion;
            public Version firmwareVersion;
            public ManusTimestamp firmwareTimestamp;
            public uint chargingState;
            public int channel;
            public UpdateStatusEnum updateStatus;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string licenseType;
            public ManusTimestamp lastSeen;
            public uint leftGloveID;
            public uint rightGloveID;
            public LicenseType licenseLevel;
            public uint netDeviceID;

            public DongleLandscapeData(uint p_Id,DeviceClassType p_ClassType,DeviceFamilyType p_FamilyType,bool p_IsHaptics,Version p_HardwareVersion,Version p_FirmwareVersion,ManusTimestamp p_FirmwareTimestamp,uint p_ChargingState,int p_Channel,UpdateStatusEnum p_UpdateStatus,string p_LicenseType,ManusTimestamp p_LastSeen,uint p_LeftGloveID,uint p_RightGloveID,LicenseType p_LicenseLevel,uint p_NetDeviceID)
            {
                id = p_Id;
                classType = p_ClassType;
                familyType = p_FamilyType;
                isHaptics = p_IsHaptics;
                hardwareVersion = p_HardwareVersion;
                firmwareVersion = p_FirmwareVersion;
                firmwareTimestamp = p_FirmwareTimestamp;
                chargingState = p_ChargingState;
                channel = p_Channel;
                updateStatus = p_UpdateStatus;
                licenseType = p_LicenseType;
                lastSeen = p_LastSeen;
                leftGloveID = p_LeftGloveID;
                rightGloveID = p_RightGloveID;
                licenseLevel = p_LicenseLevel;
                netDeviceID = p_NetDeviceID;
            }
        }

        public const int GLOVELANDSCAPEDATA_IMUCALIBRATIONINFO_ARRAY_SIZE = 6;

        /// <summary>Stores all the received glove data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct GloveLandscapeData
        {
            public uint id;
            public DeviceClassType classType;
            public DeviceFamilyType familyType;
            public Side side;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isHaptics;
            public DevicePairedState pairedState;
            public uint dongleID;
            public Version hardwareVersion;
            public Version firmwareVersion;
            public ManusTimestamp firmwareTimestamp;
            public UpdateStatusEnum updateStatus;
            public uint batteryPercentage;
            public int transmissionStrength;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 6 )]
            public IMUCalibrationInfo[] iMUCalibrationInfo;
            public ManusTimestamp lastSeen;
            [MarshalAs( UnmanagedType.I1 )]
            public bool excluded;
            public uint netDeviceID;

            public GloveLandscapeData(uint p_Id,DeviceClassType p_ClassType,DeviceFamilyType p_FamilyType,Side p_Side,bool p_IsHaptics,DevicePairedState p_PairedState,uint p_DongleID,Version p_HardwareVersion,Version p_FirmwareVersion,ManusTimestamp p_FirmwareTimestamp,UpdateStatusEnum p_UpdateStatus,uint p_BatteryPercentage,int p_TransmissionStrength,IMUCalibrationInfo[] p_IMUCalibrationInfo,ManusTimestamp p_LastSeen,bool p_Excluded,uint p_NetDeviceID)
            {
                id = p_Id;
                classType = p_ClassType;
                familyType = p_FamilyType;
                side = p_Side;
                isHaptics = p_IsHaptics;
                pairedState = p_PairedState;
                dongleID = p_DongleID;
                hardwareVersion = p_HardwareVersion;
                firmwareVersion = p_FirmwareVersion;
                firmwareTimestamp = p_FirmwareTimestamp;
                updateStatus = p_UpdateStatus;
                batteryPercentage = p_BatteryPercentage;
                transmissionStrength = p_TransmissionStrength;
                iMUCalibrationInfo = p_IMUCalibrationInfo;
                lastSeen = p_LastSeen;
                excluded = p_Excluded;
                netDeviceID = p_NetDeviceID;
            }
        }

        /// <summary>Stores informations regarding the lengths of different parts of the body.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Measurement
        {
            public MeasurementType entryType;
            public float value;
            public MeasurementUnit unit;
            public MeasurementCategory category;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string displayName;

            public Measurement(MeasurementType p_EntryType,float p_Value,MeasurementUnit p_Unit,MeasurementCategory p_Category,string p_DisplayName)
            {
                entryType = p_EntryType;
                value = p_Value;
                unit = p_Unit;
                category = p_Category;
                displayName = p_DisplayName;
            }
        }

        /// <summary>Stores the local offsets to the trackers.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerOffset
        {
            public TrackerOffsetType entryType;
            public ManusVec3 translation;
            public ManusQuaternion rotation;

            public TrackerOffset(TrackerOffsetType p_EntryType,ManusVec3 p_Translation,ManusQuaternion p_Rotation)
            {
                entryType = p_EntryType;
                translation = p_Translation;
                rotation = p_Rotation;
            }
        }

        /// <summary>Stores possible extra offsets to the trackers.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ExtraTrackerOffset
        {
            public ExtraTrackerOffsetType entryType;
            public float value;

            public ExtraTrackerOffset(ExtraTrackerOffsetType p_EntryType,float p_Value)
            {
                entryType = p_EntryType;
                value = p_Value;
            }
        }

        /// <summary>Stores all the received tracker data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerLandscapeData
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 32 )]
            public string id;
            public TrackerType type;
            public TrackerSystemType systemType;
            public uint user;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isHMD;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 32 )]
            public string manufacturer;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 32 )]
            public string productName;

            public TrackerLandscapeData(string p_Id,TrackerType p_Type,TrackerSystemType p_SystemType,uint p_User,bool p_IsHMD,string p_Manufacturer,string p_ProductName)
            {
                id = p_Id;
                type = p_Type;
                systemType = p_SystemType;
                user = p_User;
                isHMD = p_IsHMD;
                manufacturer = p_Manufacturer;
                productName = p_ProductName;
            }
        }

        public const int USERPROFILELANDSCAPEDATA_MEASUREMENTS_ARRAY_SIZE = 20;
        public const int USERPROFILELANDSCAPEDATA_TRACKEROFFSETS_ARRAY_SIZE = 14;
        public const int USERPROFILELANDSCAPEDATA_EXTRATRACKEROFFSETS_ARRAY_SIZE = 4;

        /// <summary>Stores all the received user profile data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct UserProfileLandscapeData
        {
            public ProfileType profileType;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 20 )]
            public Measurement[] measurements;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 14 )]
            public TrackerOffset[] trackerOffsets;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 4 )]
            public ExtraTrackerOffset[] extraTrackerOffsets;

            public UserProfileLandscapeData(ProfileType p_ProfileType,Measurement[] p_Measurements,TrackerOffset[] p_TrackerOffsets,ExtraTrackerOffset[] p_ExtraTrackerOffsets)
            {
                profileType = p_ProfileType;
                measurements = p_Measurements;
                trackerOffsets = p_TrackerOffsets;
                extraTrackerOffsets = p_ExtraTrackerOffsets;
            }
        }

        /// <summary>Stores all the received user data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct UserLandscapeData
        {
            public uint id;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string name;
            public Color color;
            public uint dongleID;
            public uint leftGloveID;
            public uint rightGloveID;
            public UserProfileLandscapeData profile;
            public uint userIndex;

            public UserLandscapeData(uint p_Id,string p_Name,Color p_Color,uint p_DongleID,uint p_LeftGloveID,uint p_RightGloveID,UserProfileLandscapeData p_Profile,uint p_UserIndex)
            {
                id = p_Id;
                name = p_Name;
                color = p_Color;
                dongleID = p_DongleID;
                leftGloveID = p_LeftGloveID;
                rightGloveID = p_RightGloveID;
                profile = p_Profile;
                userIndex = p_UserIndex;
            }
        }

        /// <summary>Stores all the received skeleton data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonLandscapeData
        {
            public uint id;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string session;
            public uint userId;
            public SkeletonType type;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string rootBoneName;
            [MarshalAs( UnmanagedType.I1 )]
            public bool scaled;

            public SkeletonLandscapeData(uint p_Id,string p_Session,uint p_UserId,SkeletonType p_Type,string p_RootBoneName,bool p_Scaled)
            {
                id = p_Id;
                session = p_Session;
                userId = p_UserId;
                type = p_Type;
                rootBoneName = p_RootBoneName;
                scaled = p_Scaled;
            }
        }

        public const int DEVICELANDSCAPE_DONGLES_ARRAY_SIZE = 16;
        public const int DEVICELANDSCAPE_GLOVES_ARRAY_SIZE = 32;

        /// <summary>Stores all the information related to the devices present in the landscape.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct DeviceLandscape
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 16 )]
            public DongleLandscapeData[] dongles;
            public uint dongleCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public GloveLandscapeData[] gloves;
            public uint gloveCount;

            public DeviceLandscape(DongleLandscapeData[] p_Dongles,uint p_DongleCount,GloveLandscapeData[] p_Gloves,uint p_GloveCount)
            {
                dongles = p_Dongles;
                dongleCount = p_DongleCount;
                gloves = p_Gloves;
                gloveCount = p_GloveCount;
            }
        }

        public const int USERLANDSCAPE_USERS_ARRAY_SIZE = 8;

        /// <summary>Stores all the information related to the users present in the landscape.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct UserLandscape
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 8 )]
            public UserLandscapeData[] users;
            public uint userCount;

            public UserLandscape(UserLandscapeData[] p_Users,uint p_UserCount)
            {
                users = p_Users;
                userCount = p_UserCount;
            }
        }

        public const int SKELETONLANDSCAPE_SKELETONS_ARRAY_SIZE = 32;

        /// <summary>Stores all the information related to the skeletons present in the landscape.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonLandscape
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public SkeletonLandscapeData[] skeletons;
            public uint skeletonCount;

            public SkeletonLandscape(SkeletonLandscapeData[] p_Skeletons,uint p_SkeletonCount)
            {
                skeletons = p_Skeletons;
                skeletonCount = p_SkeletonCount;
            }
        }

        public const int TRACKERLANDSCAPE_TRACKERS_ARRAY_SIZE = 128;

        /// <summary>Stores all the information related to the trackers present in the landscape.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TrackerLandscape
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 128 )]
            public TrackerLandscapeData[] trackers;
            public uint trackerCount;

            public TrackerLandscape(TrackerLandscapeData[] p_Trackers,uint p_TrackerCount)
            {
                trackers = p_Trackers;
                trackerCount = p_TrackerCount;
            }
        }

        /// <summary>Stores the license information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct LicenseInfo
        {
            [MarshalAs( UnmanagedType.I1 )]
            public bool sdkData;
            [MarshalAs( UnmanagedType.I1 )]
            public bool recordingAndPlayback;
            [MarshalAs( UnmanagedType.I1 )]
            public bool timeCode;
            [MarshalAs( UnmanagedType.I1 )]
            public bool unlimitedGloves;
            [MarshalAs( UnmanagedType.I1 )]
            public bool ergonomicData;
            [MarshalAs( UnmanagedType.I1 )]
            public bool xsensSession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool optitrackSession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool unitySession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool unrealSession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool mobuSession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool qualisysSession;
            [MarshalAs( UnmanagedType.I1 )]
            public bool vredSession;

            public LicenseInfo(bool p_SdkData,bool p_RecordingAndPlayback,bool p_TimeCode,bool p_UnlimitedGloves,bool p_ErgonomicData,bool p_XsensSession,bool p_OptitrackSession,bool p_UnitySession,bool p_UnrealSession,bool p_MobuSession,bool p_QualisysSession,bool p_VredSession)
            {
                sdkData = p_SdkData;
                recordingAndPlayback = p_RecordingAndPlayback;
                timeCode = p_TimeCode;
                unlimitedGloves = p_UnlimitedGloves;
                ergonomicData = p_ErgonomicData;
                xsensSession = p_XsensSession;
                optitrackSession = p_OptitrackSession;
                unitySession = p_UnitySession;
                unrealSession = p_UnrealSession;
                mobuSession = p_MobuSession;
                qualisysSession = p_QualisysSession;
                vredSession = p_VredSession;
            }
        }

        /// <summary>Stores the landscape settings.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SettingsLandscape
        {
            public Version manusCoreVersion;
            public LicenseInfo license;
            [MarshalAs( UnmanagedType.I1 )]
            public bool playbackMode;
            [MarshalAs( UnmanagedType.I1 )]
            public bool ignoreSessionTimeOuts;
            public FirmwareVersion firmwareOne;
            public FirmwareVersion firmwareTwo;
            [MarshalAs( UnmanagedType.I1 )]
            public bool recordingMode;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isNetDevice;
            [MarshalAs( UnmanagedType.I1 )]
            public bool isConnectedAsNetDevice;

            public SettingsLandscape(Version p_ManusCoreVersion,LicenseInfo p_License,bool p_PlaybackMode,bool p_IgnoreSessionTimeOuts,FirmwareVersion p_FirmwareOne,FirmwareVersion p_FirmwareTwo,bool p_RecordingMode,bool p_IsNetDevice,bool p_IsConnectedAsNetDevice)
            {
                manusCoreVersion = p_ManusCoreVersion;
                license = p_License;
                playbackMode = p_PlaybackMode;
                ignoreSessionTimeOuts = p_IgnoreSessionTimeOuts;
                firmwareOne = p_FirmwareOne;
                firmwareTwo = p_FirmwareTwo;
                recordingMode = p_RecordingMode;
                isNetDevice = p_IsNetDevice;
                isConnectedAsNetDevice = p_IsConnectedAsNetDevice;
            }
        }

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TimecodeInterface
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string name;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string api;
            public int index;

            public TimecodeInterface(string p_Name,string p_Api,int p_Index)
            {
                name = p_Name;
                api = p_Api;
                index = p_Index;
            }
        }

        public const int TIMELANDSCAPE_INTERFACES_ARRAY_SIZE = 32;

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TimeLandscape
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public TimecodeInterface[] interfaces;
            public uint interfaceCount;
            public TimecodeInterface currentInterface;
            public TimecodeFPS fps;
            [MarshalAs( UnmanagedType.I1 )]
            public bool fakeTimecode;
            [MarshalAs( UnmanagedType.I1 )]
            public bool useSyncPulse;
            [MarshalAs( UnmanagedType.I1 )]
            public bool deviceKeepAlive;
            [MarshalAs( UnmanagedType.I1 )]
            public bool syncStatus;
            [MarshalAs( UnmanagedType.I1 )]
            public bool timecodeStatus;
            public int ltcChannel;

            public TimeLandscape(TimecodeInterface[] p_Interfaces,uint p_InterfaceCount,TimecodeInterface p_CurrentInterface,TimecodeFPS p_Fps,bool p_FakeTimecode,bool p_UseSyncPulse,bool p_DeviceKeepAlive,bool p_SyncStatus,bool p_TimecodeStatus,int p_LtcChannel)
            {
                interfaces = p_Interfaces;
                interfaceCount = p_InterfaceCount;
                currentInterface = p_CurrentInterface;
                fps = p_Fps;
                fakeTimecode = p_FakeTimecode;
                useSyncPulse = p_UseSyncPulse;
                deviceKeepAlive = p_DeviceKeepAlive;
                syncStatus = p_SyncStatus;
                timecodeStatus = p_TimecodeStatus;
                ltcChannel = p_LtcChannel;
            }
        }

        /// <summary>Contains information about a gesture</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct GestureLandscapeData
        {
            public uint id;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 64 )]
            public string name;

            public GestureLandscapeData(uint p_Id,string p_Name)
            {
                id = p_Id;
                name = p_Name;
            }
        }

        /// <summary>Contains information about a net devices</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NetDeviceLandscapeData
        {
            public uint netDeviceID;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string hostname;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 40 )]
            public string ip;

            public NetDeviceLandscapeData(uint p_NetDeviceID,string p_Hostname,string p_Ip)
            {
                netDeviceID = p_NetDeviceID;
                hostname = p_Hostname;
                ip = p_Ip;
            }
        }

        public const int NETDEVICESLANDSCAPE_NETDEVICES_ARRAY_SIZE = 16;

        /// <summary>Contains information about a single net device</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NetDevicesLandscape
        {
            public uint numberOfNetDevices;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 16 )]
            public NetDeviceLandscapeData[] netDevices;

            public NetDevicesLandscape(uint p_NumberOfNetDevices,NetDeviceLandscapeData[] p_NetDevices)
            {
                numberOfNetDevices = p_NumberOfNetDevices;
                netDevices = p_NetDevices;
            }
        }

        /// <summary>Stores the landscape data.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Landscape
        {
            public DeviceLandscape gloveDevices;
            public UserLandscape users;
            public SkeletonLandscape skeletons;
            public TrackerLandscape trackers;
            public SettingsLandscape settings;
            public NetDevicesLandscape netDevices;
            public TimeLandscape time;
            public uint gestureCount;

            public Landscape(DeviceLandscape p_GloveDevices,UserLandscape p_Users,SkeletonLandscape p_Skeletons,TrackerLandscape p_Trackers,SettingsLandscape p_Settings,NetDevicesLandscape p_NetDevices,TimeLandscape p_Time,uint p_GestureCount)
            {
                gloveDevices = p_GloveDevices;
                users = p_Users;
                skeletons = p_Skeletons;
                trackers = p_Trackers;
                settings = p_Settings;
                netDevices = p_NetDevices;
                time = p_Time;
                gestureCount = p_GestureCount;
            }
        }

        /// <summary>Stores the inverse kinematics settings of a node, the ikAim is used to control the IK solve, 1 is default, -1 is inversed.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSettingsIK
        {
            public float ikAim;

            public NodeSettingsIK(float p_IkAim)
            {
                ikAim = p_IkAim;
            }
        }

        /// <summary>Stores the settings for a node of type foot, heightFromGround is used to set the height of the 3d model ankle from ground.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSettingsFoot
        {
            public float heightFromGround;

            public NodeSettingsFoot(float p_HeightFromGround)
            {
                heightFromGround = p_HeightFromGround;
            }
        }

        /// <summary>Stores the rotation offset of a node, this is used internally for building the skeleton.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSettingsRotationOffset
        {
            public ManusQuaternion value;

            public NodeSettingsRotationOffset(ManusQuaternion p_Value)
            {
                value = p_Value;
            }
        }

        /// <summary>Stores the settings of a node of type leaf, the direction vector is defined with respect to the previous node in the chain.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSettingsLeaf
        {
            public ManusVec3 direction;
            public float length;

            public NodeSettingsLeaf(ManusVec3 p_Direction,float p_Length)
            {
                direction = p_Direction;
                length = p_Length;
            }
        }

        /// <summary>Stores all the node settings.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSettings
        {
            public NodeSettingsFlag usedSettings;
            public NodeSettingsIK ik;
            public NodeSettingsFoot foot;
            public NodeSettingsRotationOffset rotationOffset;
            public NodeSettingsLeaf leaf;

            public NodeSettings(NodeSettingsFlag p_UsedSettings,NodeSettingsIK p_Ik,NodeSettingsFoot p_Foot,NodeSettingsRotationOffset p_RotationOffset,NodeSettingsLeaf p_Leaf)
            {
                usedSettings = p_UsedSettings;
                ik = p_Ik;
                foot = p_Foot;
                rotationOffset = p_RotationOffset;
                leaf = p_Leaf;
            }
        }

        /// <summary>
        /// <para>Stores the node setup information. Each node represents a segment of the skeleton that can be animated, nodes combine together to form chains.</para>
        /// <para>the parentID is used to identify the node with respect to which the current one will move.</para>
        /// </summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeSetup
        {
            public uint id;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string name;
            public NodeType type;
            public ManusTransform transform;
            public uint parentID;
            public NodeSettings settings;

            public NodeSetup(uint p_Id,string p_Name,NodeType p_Type,ManusTransform p_Transform,uint p_ParentID,NodeSettings p_Settings)
            {
                id = p_Id;
                name = p_Name;
                type = p_Type;
                transform = p_Transform;
                parentID = p_ParentID;
                settings = p_Settings;
            }
        }

        /// <summary>Stores all the settings of a chain of type pelvis.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsPelvis
        {
            public float hipHeight;
            public float hipBendOffset;
            public float thicknessMultiplier;

            public ChainSettingsPelvis(float p_HipHeight,float p_HipBendOffset,float p_ThicknessMultiplier)
            {
                hipHeight = p_HipHeight;
                hipBendOffset = p_HipBendOffset;
                thicknessMultiplier = p_ThicknessMultiplier;
            }
        }

        /// <summary>Stores all the settings of a chain of type leg.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsLeg
        {
            [MarshalAs( UnmanagedType.I1 )]
            public bool reverseKneeDirection;
            public float kneeRotationOffset;
            public float footForwardOffset;
            public float footSideOffset;

            public ChainSettingsLeg(bool p_ReverseKneeDirection,float p_KneeRotationOffset,float p_FootForwardOffset,float p_FootSideOffset)
            {
                reverseKneeDirection = p_ReverseKneeDirection;
                kneeRotationOffset = p_KneeRotationOffset;
                footForwardOffset = p_FootForwardOffset;
                footSideOffset = p_FootSideOffset;
            }
        }

        /// <summary>Stores all the settings of a chain of type spine.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsSpine
        {
            public float spineBendOffset;

            public ChainSettingsSpine(float p_SpineBendOffset)
            {
                spineBendOffset = p_SpineBendOffset;
            }
        }

        /// <summary>Stores all the settings of a chain of type neck.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsNeck
        {
            public float neckBendOffset;

            public ChainSettingsNeck(float p_NeckBendOffset)
            {
                neckBendOffset = p_NeckBendOffset;
            }
        }

        /// <summary>Stores all the settings of a chain of type head.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsHead
        {
            public float headPitchOffset;
            public float headYawOffset;
            public float headTiltOffset;
            [MarshalAs( UnmanagedType.I1 )]
            public bool useLeafAtEnd;

            public ChainSettingsHead(float p_HeadPitchOffset,float p_HeadYawOffset,float p_HeadTiltOffset,bool p_UseLeafAtEnd)
            {
                headPitchOffset = p_HeadPitchOffset;
                headYawOffset = p_HeadYawOffset;
                headTiltOffset = p_HeadTiltOffset;
                useLeafAtEnd = p_UseLeafAtEnd;
            }
        }

        /// <summary>Stores all the settings of a chain of type arm.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsArm
        {
            public float armLengthMultiplier;
            public float elbowRotationOffset;
            public ManusVec3 armRotationOffset;
            public ManusVec3 positionMultiplier;
            public ManusVec3 positionOffset;

            public ChainSettingsArm(float p_ArmLengthMultiplier,float p_ElbowRotationOffset,ManusVec3 p_ArmRotationOffset,ManusVec3 p_PositionMultiplier,ManusVec3 p_PositionOffset)
            {
                armLengthMultiplier = p_ArmLengthMultiplier;
                elbowRotationOffset = p_ElbowRotationOffset;
                armRotationOffset = p_ArmRotationOffset;
                positionMultiplier = p_PositionMultiplier;
                positionOffset = p_PositionOffset;
            }
        }

        /// <summary>Stores all the settings of a chain of type shoulder.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsShoulder
        {
            public float forwardOffset;
            public float shrugOffset;
            public float forwardMultiplier;
            public float shrugMultiplier;

            public ChainSettingsShoulder(float p_ForwardOffset,float p_ShrugOffset,float p_ForwardMultiplier,float p_ShrugMultiplier)
            {
                forwardOffset = p_ForwardOffset;
                shrugOffset = p_ShrugOffset;
                forwardMultiplier = p_ForwardMultiplier;
                shrugMultiplier = p_ShrugMultiplier;
            }
        }

        /// <summary>Stores all the settings of a chain of type finger.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsFinger
        {
            [MarshalAs( UnmanagedType.I1 )]
            public bool useLeafAtEnd;
            public int metacarpalBoneId;
            public int handChainId;
            public float fingerWidth;

            public ChainSettingsFinger(bool p_UseLeafAtEnd,int p_MetacarpalBoneId,int p_HandChainId,float p_FingerWidth)
            {
                useLeafAtEnd = p_UseLeafAtEnd;
                metacarpalBoneId = p_MetacarpalBoneId;
                handChainId = p_HandChainId;
                fingerWidth = p_FingerWidth;
            }
        }

        public const int CHAINSETTINGSHAND_FINGERCHAINIDS_ARRAY_SIZE = 10;

        /// <summary>Stores all the settings of a chain of type hand.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsHand
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 10 )]
            public int[] fingerChainIds;
            public int fingerChainIdsUsed;
            public HandMotion handMotion;

            public ChainSettingsHand(int[] p_FingerChainIds,int p_FingerChainIdsUsed,HandMotion p_HandMotion)
            {
                fingerChainIds = p_FingerChainIds;
                fingerChainIdsUsed = p_FingerChainIdsUsed;
                handMotion = p_HandMotion;
            }
        }

        public const int CHAINSETTINGSFOOT_TOECHAINIDS_ARRAY_SIZE = 10;

        /// <summary>Stores all the settings of a chain of type foot.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsFoot
        {
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 10 )]
            public int[] toeChainIds;
            public int toeChainIdsUsed;

            public ChainSettingsFoot(int[] p_ToeChainIds,int p_ToeChainIdsUsed)
            {
                toeChainIds = p_ToeChainIds;
                toeChainIdsUsed = p_ToeChainIdsUsed;
            }
        }

        /// <summary>Stores all the settings of a chain of type toe.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettingsToe
        {
            public int footChainId;
            [MarshalAs( UnmanagedType.I1 )]
            public bool useLeafAtEnd;

            public ChainSettingsToe(int p_FootChainId,bool p_UseLeafAtEnd)
            {
                footChainId = p_FootChainId;
                useLeafAtEnd = p_UseLeafAtEnd;
            }
        }

        /// <summary>Stores all chain settings.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSettings
        {
            public ChainType usedSettings;
            public ChainSettingsPelvis pelvis;
            public ChainSettingsLeg leg;
            public ChainSettingsSpine spine;
            public ChainSettingsNeck neck;
            public ChainSettingsHead head;
            public ChainSettingsArm arm;
            public ChainSettingsShoulder shoulder;
            public ChainSettingsFinger finger;
            public ChainSettingsHand hand;
            public ChainSettingsFoot foot;
            public ChainSettingsToe toe;

            public ChainSettings(ChainType p_UsedSettings,ChainSettingsPelvis p_Pelvis,ChainSettingsLeg p_Leg,ChainSettingsSpine p_Spine,ChainSettingsNeck p_Neck,ChainSettingsHead p_Head,ChainSettingsArm p_Arm,ChainSettingsShoulder p_Shoulder,ChainSettingsFinger p_Finger,ChainSettingsHand p_Hand,ChainSettingsFoot p_Foot,ChainSettingsToe p_Toe)
            {
                usedSettings = p_UsedSettings;
                pelvis = p_Pelvis;
                leg = p_Leg;
                spine = p_Spine;
                neck = p_Neck;
                head = p_Head;
                arm = p_Arm;
                shoulder = p_Shoulder;
                finger = p_Finger;
                hand = p_Hand;
                foot = p_Foot;
                toe = p_Toe;
            }
        }

        public const int CHAINSETUP_NODEIDS_ARRAY_SIZE = 32;

        /// <summary>Stores the chain setup information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ChainSetup
        {
            public uint id;
            public ChainType type;
            public ChainType dataType;
            public uint dataIndex;
            public uint nodeIdCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public uint[] nodeIds;
            public ChainSettings settings;
            public Side side;

            public ChainSetup(uint p_Id,ChainType p_Type,ChainType p_DataType,uint p_DataIndex,uint p_NodeIdCount,uint[] p_NodeIds,ChainSettings p_Settings,Side p_Side)
            {
                id = p_Id;
                type = p_Type;
                dataType = p_DataType;
                dataIndex = p_DataIndex;
                nodeIdCount = p_NodeIdCount;
                nodeIds = p_NodeIds;
                settings = p_Settings;
                side = p_Side;
            }
        }

        /// <summary>Stores all the settings of a collider of type sphere.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SphereColliderSetup
        {
            public float radius;

            public SphereColliderSetup(float p_Radius)
            {
                radius = p_Radius;
            }
        }

        /// <summary>Stores all the settings of a collider of type capsule.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct CapsuleColliderSetup
        {
            public float radius;
            public float length;

            public CapsuleColliderSetup(float p_Radius,float p_Length)
            {
                radius = p_Radius;
                length = p_Length;
            }
        }

        /// <summary>Stores all the settings of a collider of type box.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct BoxColliderSetup
        {
            public ManusVec3 size;

            public BoxColliderSetup(ManusVec3 p_Size)
            {
                size = p_Size;
            }
        }

        /// <summary>Stores the collider setup information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct ColliderSetup
        {
            public uint nodeID;
            public ManusVec3 localPosition;
            public ManusVec3 localRotation;
            public ColliderType type;
            public SphereColliderSetup sphere;
            public CapsuleColliderSetup capsule;
            public BoxColliderSetup box;

            public ColliderSetup(uint p_NodeID,ManusVec3 p_LocalPosition,ManusVec3 p_LocalRotation,ColliderType p_Type,SphereColliderSetup p_Sphere,CapsuleColliderSetup p_Capsule,BoxColliderSetup p_Box)
            {
                nodeID = p_NodeID;
                localPosition = p_LocalPosition;
                localRotation = p_LocalRotation;
                type = p_Type;
                sphere = p_Sphere;
                capsule = p_Capsule;
                box = p_Box;
            }
        }

        /// <summary>Stores the vertex weight information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Weight
        {
            public uint nodeID;
            public float weightValue;

            public Weight(uint p_NodeID,float p_WeightValue)
            {
                nodeID = p_NodeID;
                weightValue = p_WeightValue;
            }
        }

        public const int VERTEX_WEIGHTS_ARRAY_SIZE = 4;

        /// <summary>Stores the vertex information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Vertex
        {
            public ManusVec3 position;
            public uint weightsCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 4 )]
            public Weight[] weights;

            public Vertex(ManusVec3 p_Position,uint p_WeightsCount,Weight[] p_Weights)
            {
                position = p_Position;
                weightsCount = p_WeightsCount;
                weights = p_Weights;
            }
        }

        /// <summary>Stores the triangle information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct Triangle
        {
            public int vertexIndex1;
            public int vertexIndex2;
            public int vertexIndex3;

            public Triangle(int p_VertexIndex1,int p_VertexIndex2,int p_VertexIndex3)
            {
                vertexIndex1 = p_VertexIndex1;
                vertexIndex2 = p_VertexIndex2;
                vertexIndex3 = p_VertexIndex3;
            }
        }

        /// <summary>Stores the information regarding the user data used to animate the skeleton.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonTargetUserData
        {
            public uint userID;

            public SkeletonTargetUserData(uint p_UserID)
            {
                userID = p_UserID;
            }
        }

        /// <summary>Stores the information regarding the user index data used to animate the skeleton.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonTargetUserIndexData
        {
            public uint userIndex;

            public SkeletonTargetUserIndexData(uint p_UserIndex)
            {
                userIndex = p_UserIndex;
            }
        }

        /// <summary>Stores the information regarding the animation data used to animate the skeleton.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonTargetAnimationData
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 32 )]
            public string id;

            public SkeletonTargetAnimationData(string p_Id)
            {
                id = p_Id;
            }
        }

        /// <summary>Stores the information regarding the glove data used to animate the skeleton.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonTargetGloveData
        {
            public uint gloveID;

            public SkeletonTargetGloveData(uint p_GloveID)
            {
                gloveID = p_GloveID;
            }
        }

        /// <summary>Stores all the possible skeleton settings.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonSettings
        {
            [MarshalAs( UnmanagedType.I1 )]
            public bool scaleToTarget;
            [MarshalAs( UnmanagedType.I1 )]
            public bool useEndPointApproximations;
            public CollisionType collisionType;
            public SkeletonTargetType targetType;
            public SkeletonTargetUserData skeletonTargetUserData;
            public SkeletonTargetUserIndexData skeletonTargetUserIndexData;
            public SkeletonTargetAnimationData skeletonTargetAnimationData;
            public SkeletonTargetGloveData skeletonGloveData;

            public SkeletonSettings(bool p_ScaleToTarget,bool p_UseEndPointApproximations,CollisionType p_CollisionType,SkeletonTargetType p_TargetType,SkeletonTargetUserData p_SkeletonTargetUserData,SkeletonTargetUserIndexData p_SkeletonTargetUserIndexData,SkeletonTargetAnimationData p_SkeletonTargetAnimationData,SkeletonTargetGloveData p_SkeletonGloveData)
            {
                scaleToTarget = p_ScaleToTarget;
                useEndPointApproximations = p_UseEndPointApproximations;
                collisionType = p_CollisionType;
                targetType = p_TargetType;
                skeletonTargetUserData = p_SkeletonTargetUserData;
                skeletonTargetUserIndexData = p_SkeletonTargetUserIndexData;
                skeletonTargetAnimationData = p_SkeletonTargetAnimationData;
                skeletonGloveData = p_SkeletonGloveData;
            }
        }

        /// <summary>Stores the skeleton setup information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonSetupInfo
        {
            public uint id;
            public SkeletonType type;
            public SkeletonSettings settings;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string name;

            public SkeletonSetupInfo(uint p_Id,SkeletonType p_Type,SkeletonSettings p_Settings,string p_Name)
            {
                id = p_Id;
                type = p_Type;
                settings = p_Settings;
                name = p_Name;
            }
        }

        /// <summary>Stores the amount of nodes and chains in the skeleton setup.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SkeletonSetupArraySizes
        {
            public uint nodesCount;
            public uint chainsCount;
            public uint collidersCount;
            public uint meshCount;

            public SkeletonSetupArraySizes(uint p_NodesCount,uint p_ChainsCount,uint p_CollidersCount,uint p_MeshCount)
            {
                nodesCount = p_NodesCount;
                chainsCount = p_ChainsCount;
                collidersCount = p_CollidersCount;
                meshCount = p_MeshCount;
            }
        }

        /// <summary>Stores the temporary skeleton information.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TemporarySkeletonInfo
        {
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string name;
            public uint index;

            public TemporarySkeletonInfo(string p_Name,uint p_Index)
            {
                name = p_Name;
                index = p_Index;
            }
        }

        public const int TEMPORARYSKELETONSINFOFORSESSION_SKELETONINFO_ARRAY_SIZE = 32;

        /// <summary>Stores the temporary skeletons available for a specific session.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TemporarySkeletonsInfoForSession
        {
            public uint sessionId;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string sessionName;
            public uint skeletonCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 32 )]
            public TemporarySkeletonInfo[] skeletonInfo;

            public TemporarySkeletonsInfoForSession(uint p_SessionId,string p_SessionName,uint p_SkeletonCount,TemporarySkeletonInfo[] p_SkeletonInfo)
            {
                sessionId = p_SessionId;
                sessionName = p_SessionName;
                skeletonCount = p_SkeletonCount;
                skeletonInfo = p_SkeletonInfo;
            }
        }

        /// <summary>Stores the temporary skeletons available for a specific session.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TemporarySkeletonCountForSession
        {
            public uint sessionId;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string sessionName;
            public uint skeletonCount;

            public TemporarySkeletonCountForSession(uint p_SessionId,string p_SessionName,uint p_SkeletonCount)
            {
                sessionId = p_SessionId;
                sessionName = p_SessionName;
                skeletonCount = p_SkeletonCount;
            }
        }

        public const int TEMPORARYSKELETONCOUNTFORALLSESSIONS_TEMPORARYSKELETONCOUNTFORSESSIONS_ARRAY_SIZE = 8;

        /// <summary>Stores the temporary skeleton available for all sessions connected to Core.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TemporarySkeletonCountForAllSessions
        {
            public uint sessionsCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 8 )]
            public TemporarySkeletonCountForSession[] temporarySkeletonCountForSessions;

            public TemporarySkeletonCountForAllSessions(uint p_SessionsCount,TemporarySkeletonCountForSession[] p_TemporarySkeletonCountForSessions)
            {
                sessionsCount = p_SessionsCount;
                temporarySkeletonCountForSessions = p_TemporarySkeletonCountForSessions;
            }
        }

        public const int TEMPORARYSKELETONSESSIONSDATA_TEMPORARYSKELETONSSESSIONS_ARRAY_SIZE = 8;

        /// <summary>ONLY USED INTERNALLY</summary>
        /// <remarks>Stores the temporary skeleton available for all sessions connected to Core.</remarks>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct TemporarySkeletonSessionsData
        {
            public uint sessionsCount;
            [MarshalAs( UnmanagedType.ByValArray, SizeConst = 8 )]
            public TemporarySkeletonsInfoForSession[] temporarySkeletonsSessions;

            public TemporarySkeletonSessionsData(uint p_SessionsCount,TemporarySkeletonsInfoForSession[] p_TemporarySkeletonsSessions)
            {
                sessionsCount = p_SessionsCount;
                temporarySkeletonsSessions = p_TemporarySkeletonsSessions;
            }
        }

        /// <summary>Stores the data associated to System messages received from Core.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct SystemMessage
        {
            public SystemMessageType type;
            [MarshalAs( UnmanagedType.ByValTStr, SizeConst = 256 )]
            public string infoString;
            public uint infoUInt;

            public SystemMessage(SystemMessageType p_Type,string p_InfoString,uint p_InfoUInt)
            {
                type = p_Type;
                infoString = p_InfoString;
                infoUInt = p_InfoUInt;
            }
        }

        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct NodeInfo
        {
            public uint nodeId;
            public uint parentId;
            public ChainType chainType;
            public Side side;
            public FingerJointType fingerJointType;

            public NodeInfo(uint p_NodeId,uint p_ParentId,ChainType p_ChainType,Side p_Side,FingerJointType p_FingerJointType)
            {
                nodeId = p_NodeId;
                parentId = p_ParentId;
                chainType = p_ChainType;
                side = p_Side;
                fingerJointType = p_FingerJointType;
            }
        }

        /// <summary>Stores the information regarding the coordinate system used by the client, defined as VUH (view, up, handedness).</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct CoordinateSystemVUH
        {
            public AxisView view;
            public AxisPolarity up;
            public Side handedness;
            public float unitScale;

            public CoordinateSystemVUH(AxisView p_View,AxisPolarity p_Up,Side p_Handedness,float p_UnitScale)
            {
                view = p_View;
                up = p_Up;
                handedness = p_Handedness;
                unitScale = p_UnitScale;
            }
        }

        /// <summary>Stores the information regarding the coordinate system used by the client, defined by each axis direction.</summary>
        [System.Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct CoordinateSystemDirection
        {
            public AxisDirection x;
            public AxisDirection y;
            public AxisDirection z;
            public float unitScale;

            public CoordinateSystemDirection(AxisDirection p_X,AxisDirection p_Y,AxisDirection p_Z,float p_UnitScale)
            {
                x = p_X;
                y = p_Y;
                z = p_Z;
                unitScale = p_UnitScale;
            }
        }
    }
}
